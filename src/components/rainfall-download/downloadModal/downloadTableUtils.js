import {
  parseZonedDateTime,
  setDateTimeOffset,
  toDateTime
} from "../../store/utils/dateTime";

export const EXCEL_DATETIME_FORMAT = "MM/DD/YYYY HH:mm:ss";
export const SWMM_DATETIME_FORMAT = "MM/DD/YYYY HH:mm";
export const CHART_TIMESTAMP_RULE = {
  start: "start",
  midpoint: "midpoint",
  end: "end"
};
export const CHART_SERIES_MODE = {
  perSensor: "perSensor",
  averageByType: "averageByType"
};

const PREFERRED_FIELD_ORDER = ["start_ts", "end_ts", "ts", "val", "src", "id", "type"];
const CHART_AVERAGE_DECIMAL_PLACES = 3;
const SWMM_DEFAULT_INTERVAL = "0:00";
const SWMM_ROLLUP_TO_INTERVAL = {
  "5-minute": "0:05",
  "15-minute": "0:15",
  hourly: "1:00",
  daily: "24:00",
  total: "0:00"
};

const sanitizeSwmmIdentifier = (rawValue, fallback = "SENSOR") => {
  const normalized = `${rawValue ?? ""}`
    .trim()
    .toUpperCase()
    .replace(/[^A-Z0-9_]/g, "_")
    .replace(/_+/g, "_")
    .replace(/^_+|_+$/g, "");

  const base = normalized.length > 0 ? normalized : fallback;
  return /^[A-Z]/.test(base) ? base : `S_${base}`;
};

const formatSwmmValue = (value) => `${Number(value.toFixed(6))}`;
const roundChartAverageValue = (value) => Number(value.toFixed(CHART_AVERAGE_DECIMAL_PLACES));

const parseSwmmTimestamp = (rawTimestamp, rule = CHART_TIMESTAMP_RULE.start) => {
  if (typeof rawTimestamp !== "string") {
    return null;
  }

  const rangeParts = rawTimestamp.split("/");
  if (rangeParts.length === 2) {
    const start = parseZonedDateTime(rangeParts[0].trim(), true);
    const end = parseZonedDateTime(rangeParts[1].trim(), true);

    if (!start || !end) {
      return null;
    }

    if (rule === CHART_TIMESTAMP_RULE.end) {
      return end;
    }

    if (rule === CHART_TIMESTAMP_RULE.midpoint) {
      return setDateTimeOffset(
        toDateTime(Math.round((start.valueOf() + end.valueOf()) / 2)),
        start.utcOffset()
      );
    }

    return start;
  }

  return parseZonedDateTime(rawTimestamp, true);
};

export const getSwmmIntervalFromRollup = (rollup) => {
  if (typeof rollup !== "string") {
    return SWMM_DEFAULT_INTERVAL;
  }

  const normalized = rollup.trim().toLowerCase();
  return SWMM_ROLLUP_TO_INTERVAL[normalized] || SWMM_DEFAULT_INTERVAL;
};

export const buildSwmmInpSnippet = (resultsTableData, options = {}) => {
  const timestampRule = options.timestampRule || CHART_TIMESTAMP_RULE.start;
  const interval = getSwmmIntervalFromRollup(options.rollup);
  const sensorsByKey = new Map();
  const sensorTypes = Object.keys(resultsTableData || {});

  sensorTypes.forEach((sensorType) => {
    const sensorRows = resultsTableData[sensorType];
    if (!Array.isArray(sensorRows)) {
      return;
    }

    sensorRows.forEach((sensorRow) => {
      const sensorId = sensorRow?.id;
      if (sensorId === null || sensorId === undefined || sensorId === "") {
        return;
      }

      const sensorIdString = `${sensorId}`;
      const key = `${sensorType}:${sensorIdString}`;
      const safeSensorKey = sanitizeSwmmIdentifier(`${sensorType}_${sensorIdString}`);

      if (!sensorsByKey.has(key)) {
        sensorsByKey.set(key, {
          sensorType: `${sensorType}`,
          sensorId: sensorIdString,
          gageName: sanitizeSwmmIdentifier(`RG_${safeSensorKey}`, "RG_SENSOR"),
          seriesName: sanitizeSwmmIdentifier(`TS_${safeSensorKey}`, "TS_SENSOR"),
          points: []
        });
      }

      const sensorDataRows = Array.isArray(sensorRow?.data) ? sensorRow.data : [];
      sensorDataRows.forEach((sensorDataRow) => {
        const timestamp = parseSwmmTimestamp(sensorDataRow?.ts, timestampRule);
        const value = Number(sensorDataRow?.val);

        if (timestamp === null || !Number.isFinite(value)) {
          return;
        }

        sensorsByKey.get(key).points.push({
          timestampMs: timestamp.valueOf(),
          dateTime: timestamp.format(SWMM_DATETIME_FORMAT),
          value: value
        });
      });
    });
  });

  const orderedSensors = [...sensorsByKey.values()]
    .map((sensor) => ({
      ...sensor,
      points: [...sensor.points].sort((left, right) => left.timestampMs - right.timestampMs)
    }))
    .filter((sensor) => sensor.points.length > 0)
    .sort((left, right) => {
      const typeCompare = left.sensorType.localeCompare(right.sensorType);
      if (typeCompare !== 0) {
        return typeCompare;
      }
      return left.sensorId.localeCompare(right.sensorId, undefined, { numeric: true, sensitivity: "base" });
    });

  const lines = [
    ";;Rainfall export for EPA SWMM",
    ";;Generated by the 3RWW Rainfall app",
    "",
    "[RAINGAGES]",
    ";;Name Form Intvl SCF DataSource SourceName"
  ];

  if (orderedSensors.length === 0) {
    lines.push(";;No valid rainfall rows available.");
  } else {
    orderedSensors.forEach((sensor) => {
      lines.push(`${sensor.gageName} VOLUME ${interval} 1.0 TIMESERIES ${sensor.seriesName}`);
    });
  }

  lines.push("", "[TIMESERIES]", ";;Name Date Time Value");

  if (orderedSensors.length === 0) {
    lines.push(";;No valid rainfall rows available.");
  } else {
    orderedSensors.forEach((sensor) => {
      sensor.points.forEach((point) => {
        const [date, time] = point.dateTime.split(" ");
        lines.push(`${sensor.seriesName} ${date} ${time} ${formatSwmmValue(point.value)}`);
      });
    });
  }

  return lines.join("\n");
};

export const formatIsoForExcel = (rawValue) => {
  if (typeof rawValue !== "string") {
    return null;
  }

  const parsed = parseZonedDateTime(rawValue, true);
  if (!parsed) {
    return null;
  }

  return parsed.format(EXCEL_DATETIME_FORMAT);
};

export const normalizeDownloadRow = (row) => {
  const normalized = { ...row };
  const rawTimestamp = normalized.ts;

  if (typeof rawTimestamp !== "string") {
    return normalized;
  }

  const rangeParts = rawTimestamp.split("/");
  if (rangeParts.length === 2) {
    const startTimestamp = formatIsoForExcel(rangeParts[0].trim());
    const endTimestamp = formatIsoForExcel(rangeParts[1].trim());

    if (startTimestamp !== null && endTimestamp !== null) {
      const { ts, ...withoutTs } = normalized;
      return {
        ...withoutTs,
        start_ts: startTimestamp,
        end_ts: endTimestamp
      };
    }

    return normalized;
  }

  const formattedTimestamp = formatIsoForExcel(rawTimestamp);
  if (formattedTimestamp === null) {
    return normalized;
  }

  return {
    ...normalized,
    ts: formattedTimestamp
  };
};

export const buildDownloadRowsAndFields = (resultsTableData) => {
  const rows = [];
  const sensorTypes = Object.keys(resultsTableData || {});

  sensorTypes.forEach((sensorType) => {
    const sensorRows = resultsTableData[sensorType];
    if (!Array.isArray(sensorRows)) {
      return;
    }

    sensorRows.forEach((sensorRow) => {
      const sensorDataRows = Array.isArray(sensorRow?.data) ? sensorRow.data : [];
      sensorDataRows.forEach((sensorDataRow) => {
        rows.push(
          normalizeDownloadRow({
            ...sensorDataRow,
            id: sensorRow?.id,
            type: sensorType
          })
        );
      });
    });
  });

  const allKeys = new Set();
  const extraFieldOrder = [];

  rows.forEach((row) => {
    Object.keys(row).forEach((key) => {
      allKeys.add(key);
      if (!PREFERRED_FIELD_ORDER.includes(key) && !extraFieldOrder.includes(key)) {
        extraFieldOrder.push(key);
      }
    });
  });

  const orderedPreferredFields = PREFERRED_FIELD_ORDER.filter((key) => allKeys.has(key));

  return {
    rows: rows,
    fields: [...orderedPreferredFields, ...extraFieldOrder]
  };
};

const buildSensorLabel = (sensorType, sensorId) => {
  const readableType = typeof sensorType === "string" && sensorType.length > 0
    ? `${sensorType[0].toUpperCase()}${sensorType.slice(1)}`
    : "Sensor";
  return `${readableType} ${sensorId}`;
};

const buildAverageLabel = (sensorType) => {
  const readableType = typeof sensorType === "string" && sensorType.length > 0
    ? `${sensorType[0].toUpperCase()}${sensorType.slice(1)}`
    : "Sensor";
  return `${readableType} Average`;
};

export const extractChartTimestamp = (rawTimestamp, rule = CHART_TIMESTAMP_RULE.start) => {
  if (typeof rawTimestamp !== "string") {
    return null;
  }

  const rangeParts = rawTimestamp.split("/");
  if (rangeParts.length === 2) {
    const start = parseZonedDateTime(rangeParts[0].trim(), true);
    const end = parseZonedDateTime(rangeParts[1].trim(), true);

    if (!start || !end) {
      return null;
    }

    if (rule === CHART_TIMESTAMP_RULE.end) {
      return end.valueOf();
    }

    if (rule === CHART_TIMESTAMP_RULE.midpoint) {
      return Math.round((start.valueOf() + end.valueOf()) / 2);
    }

    return start.valueOf();
  }

  const parsed = parseZonedDateTime(rawTimestamp, true);
  if (!parsed) {
    return null;
  }
  return parsed.valueOf();
};

export const buildDownloadChartData = (resultsTableData, options = {}) => {
  const timestampRule = options.timestampRule || CHART_TIMESTAMP_RULE.start;
  const seriesMode = options.seriesMode || CHART_SERIES_MODE.perSensor;
  const rowsByTimestamp = new Map();
  const series = [];
  const seenSeriesKeys = new Set();
  const sensorTypes = Object.keys(resultsTableData || {});

  sensorTypes.forEach((sensorType) => {
    const sensorRows = resultsTableData[sensorType];
    if (!Array.isArray(sensorRows)) {
      return;
    }

    sensorRows.forEach((sensorRow) => {
      const sensorId = sensorRow?.id;
      if (sensorId === null || sensorId === undefined || sensorId === "") {
        return;
      }

      const sensorDataRows = Array.isArray(sensorRow?.data) ? sensorRow.data : [];

      sensorDataRows.forEach((sensorDataRow) => {
        const timestampMs = extractChartTimestamp(sensorDataRow?.ts, timestampRule);
        const value = Number(sensorDataRow?.val);

        if (timestampMs === null || !Number.isFinite(value)) {
          return;
        }

        if (seriesMode === CHART_SERIES_MODE.averageByType) {
          const seriesKey = `avg:${sensorType}`;

          if (!seenSeriesKeys.has(seriesKey)) {
            seenSeriesKeys.add(seriesKey);
            series.push({
              key: seriesKey,
              label: buildAverageLabel(sensorType),
              sensorType: sensorType
            });
          }

          const existingRow = rowsByTimestamp.get(timestampMs) || { timestampMs: timestampMs };
          const existingAggregate = existingRow[seriesKey] || { sum: 0, count: 0 };
          existingAggregate.sum += value;
          existingAggregate.count += 1;
          existingRow[seriesKey] = existingAggregate;
          rowsByTimestamp.set(timestampMs, existingRow);
          return;
        }

        const seriesKey = `${sensorType}:${sensorId}`;

        if (!seenSeriesKeys.has(seriesKey)) {
          seenSeriesKeys.add(seriesKey);
          series.push({
            key: seriesKey,
            label: buildSensorLabel(sensorType, sensorId),
            sensorType: sensorType,
            sensorId: sensorId
          });
        }

        const existingRow = rowsByTimestamp.get(timestampMs) || { timestampMs: timestampMs };
        existingRow[seriesKey] = value;
        rowsByTimestamp.set(timestampMs, existingRow);
      });
    });
  });

  const rows = [...rowsByTimestamp.values()]
    .map((row) => {
      if (seriesMode !== CHART_SERIES_MODE.averageByType) {
        return row;
      }

      const averagedRow = { timestampMs: row.timestampMs };
      series.forEach((seriesItem) => {
        const aggregate = row[seriesItem.key];
        if (aggregate && aggregate.count > 0) {
          averagedRow[seriesItem.key] = roundChartAverageValue(aggregate.sum / aggregate.count);
        }
      });
      return averagedRow;
    })
    .sort((left, right) => left.timestampMs - right.timestampMs);

  return {
    rows: rows,
    series: series
  };
};
